# 條款 02 了解 JavaScript 的浮點數字

## Javascript 的數字特性

多數的語言，都有很多種數字型別，JavaScript，只有一種: `number` 型別，其實都是 `double-precision` 數字 ([IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 的 64 位元數字)。

### IEEE 754

稱呼: 
1. 標準的全名: IEEE二進位浮點數算術標準 (ANSI/IEEE Std 754-1985)
1. 又稱IEC 60559:1989，微處理器系統的二進位浮點數算術 (本來的編號是IEC 559:1989)。
1. 還有「與基數無關的浮點數」的「IEEE 854-1987標準」，有規定基數為2跟10的狀況。
1. 現在最新標準是「ISO/IEC/IEEE FDIS 60559:2010」。

制定的特殊值

|值|指數|小數| 正負號 |
|-|-|-|-|
| `±0` | 0 | 0 | 符號位相關 |
| `±Infinity` | 2^e - 1 | 0 | 符號位相關 |
| NaN | 2^e - 1 | 非0 | 符號位無關 |

> 正負號，指的是逼近 0 或 Infinity 的方向

### 互換 string 和 number 的方式

**string to number**

- `parseInt("30")`
- `parseFloat("30")`
- `"30" | 0` // only 32-bit

**number to string**

- `3 .toString()`
- `3 .toString(2)` // 轉二進制


## 整數

在 double 中的整數，有效表示範圍
-9007199254740992 (-2^53) 到 9007199254740992 (2^53)

## 32 位元 `signed integer` 的位元運算

位元的算術運算子包括: 
- 位元運算運算子: `~`、`&`、`|`、`^`
- 位移運算子 (shift operator): `<<`、`>>`、`>>>`

計算時不會把引數 (arguments) 當浮點數來運算，而會視為 32 位元的 (big-endian) 二補數整數。

**例如: 8 | 1 = 9**

```javascript
8 | 1;  // 9
```

計算過程很像這樣:

1. 將 8 轉為二進位 (32 位元): `00000000000000000000000000001000`
1. 將 1 轉為二進位 (32 位元): `00000000000000000000000000000001`
1. 進行 OR 運算後會變成: `00000000000000000000000000001001`
1. 將 `1001` 轉成 10 進位: 

```javascript
parseInt('1001', 2);  // 9
```

**例如: 8888888888 經過位元運算變 298954296**

另一個範例: 為何 `8888888888 | 1` 會等於 `298954297`？

```javascript
298954296 | 1;  // 298954297
```

因為`8888888888` 轉為二進位是 `1000010001110100011010111000111000` (34 位元): 

```javascript
(8888888888).toString(2);  // "1000010001110100011010111000111000"
"1000010001110100011010111000111000".length;  // 34
```

但位元運算只會用到 32 位元，所以當 `8888888888 | 1` 運算時，就會去掉多餘的位元，像 `8888888888` 的二進位 (因有 34 位元，會被去掉兩個位元) 最前面的 `10` 這兩個位元就會被去掉，所以實際上位元運算是這樣: 

```javascript
parseInt("00010001110100011010111000111000", 2);  // 298954296

298954296 | 1;  // 298954297
```

## 浮點數

### 浮點誤差

```javascript
0.1 + 0.2;  // 0.30000000000000004


  ```javascript
  0.1 + 0.2 = 0.30000000000000004;
  0.1 + 0.2 === 0.3; // false
  ```

  > 盡量運用整數做運算可以避免誤差：

  ```javascript
  const caryOver = 10;
浮點數運算，如果超過 64 位元的話會有捨入誤差。

```javascript
0.1 + 0.2 = 0.30000000000000004;
0.1 + 0.2 === 0.3;  // false
```

一般來說，`(x + y) + z = x + (y + z)`，但 JS 的浮點數並不一定: 

```javascript
(0.1 + 0.2) + 0.3; // 0.6000000000000001
0.1 + (0.2 + 0.3); // 0.6
```

### 避免方式浮點誤差

**運用整數做運算**

```
(0.1 + 0.2) + 0.3; // 0.6000000000000001
0.1 + (0.2 + 0.3); // 0.6
```

所以建議用整數運算：

```javascript
const caryOver = 10;
if ((0.1 * caryOver + 0.2 * caryOver)/caryOver === 0.3) //true
```

```javascript
(10 + 20) + 30; // 60
10 + (20 + 30); // 60
```

**運用夾擊判斷**

建議：
- 放大浮點數，以整數來計算就不會發生運算結果不精確的問題
  - 使用整數就能處理 $-2^{53}$ 到 $2^{53}$ 範圍間的所有計算，且不用擔心捨入誤差 (rounding errors)
解決方式：
盡量使用範圍在 –2 ^53 和 2 ^53 之間的整數進行計算，然後再處理放大倍數
```javascript
const value = 0.1 + 0.2;
value // 0.30000000000000004
if (0.2999999 < value && value < 0.3000001)
```

**運用 JavaScript 的可忽略誤差: `Number.EPSILON`**

1、JS 的數字都是 double-precision floating-point，整數是其中一個子集，不是單獨的資料型別
2、位元運算子將數字視為 32 bits 的有符號整數
3、小心浮點數計算的精度問題
```javascript
function numbersCloseEnoughToEqual(n1,n2) {
	return Math.abs( n1 - n2 ) < Number.EPSILON;
}
```

```javascript
var a = 0.1 + 0.2;
var b = 0.3;
numbersCloseEnoughToEqual( a, b );	// true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );
```

```javascript
numbersCloseEnoughToEqual((0.1 + 0.2) + 0.3, 0.6)
```
