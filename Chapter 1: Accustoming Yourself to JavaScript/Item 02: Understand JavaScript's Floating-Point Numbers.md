# 條款 02 了解 JavaScript 的浮點數字

多數的語言，都有很多種數字型別。
JavaScript，只有一種: `number`，包含了`integers`和`floating-point number`

事實上 JavaScript 中所有的數字都是 `double-precision floating-point` [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 的 64位元數字


### 條款 02 了解 Javascript 的浮點數字
#### Javascript 的數字特性
- 用 `typeof` 檢查，整數與浮點數都是同一個 number 型別。
- 是由 IEEE 754 規範的 64 位元數字編碼（俗稱 double）。
- 整數最精準可以運算至 53 位元。
- 位元運算子是將值作為 32 位元的二進位運算。
    ```javascript
    (8).toString(2);      // '1000'
    (1).toString(2);      // '0001'
    
    8 | 1;                // 1001 => 9
    parseInt('1001', 2);  // 9
    ```
- 浮點數運算，如果超過 64 位元的話會有捨入誤差。
    ```javascript
    0.1 + 0.2 = 0.30000000000000004;
    0.1 + 0.2 === 0.3;  // false
    ```
    > 盡量運用整數做運算可以避免誤差：
    ```javascript
    const caryOver = 10;

    (0.1 * caryOver + 0.2 * caryOver)/caryOver === 0.3 //true

- bitwise不理解

- bitwise不理解
整理：
- JS 的數字是雙精度的浮點數
- JS 的整數只是 double 的一個子集合，而非個別的資料型別
- 位元運算子把數字當成 32 位元的 signed integer 來看
- 小心浮點數算術中的精確度限制

## JS 只有 number 型別，沒有 integer 和 float，但本質是 double

JS 把整數 (integer) 和浮點數 (floating-point number) 都分類為數字 (number)。

但 JS 所有的數字都是雙精度的浮點數 (double-precision floating-point)，也就是由 IEEE754 標準所規範的 64 位元數字標碼，常被稱為 "double"。

JS 的整數會被 double 來表示，最多到 53 位元的精確度，從 -9007199254740992 ( $-2^{53}$ ) 到 9007199254740992 ( $2^{53}$ ) 的整數都是有效的 double，所以JS 的整數和實數都可拿來作算術計算。

## 位元運算只會用 32 位元進行運算

位元運算包括：
- 位元運算運算子：`~`、`&`、`|`、`^`
- 位移運算子 (shift operator)：`<<`、`>>`、`>>>`

位元算術運算子不會把 arg 直接當作浮點數來運算，而是會視為 32 位元的 big-endian 二補數整數。例如：

```javascript
8 | 1;  // 9
```

計算過程很像這樣：
- 將 8 轉為二進位 (32 位元)：`00000000000000000000000000001000`
- 將 1 轉為二進位 (32 位元)：`00000000000000000000000000000001`

```javascript
(8).toString(2);  // "1000"
(1).toString(2);  // "1"
```

進行 OR 運算後會變成：`00000000000000000000000000001001`

將 `1001` 轉成 10 進位：

```javascript
parseInt('1001', 2);  // 9
```

另一個範例：為何 `8888888888 | 1` 會等於 `298954297`？

```javascript
298954296 | 1;  // 298954297
```

因為`8888888888` 轉為二進位是 `1000010001110100011010111000111000` (34 位元)：

```javascript
(8888888888).toString(2);  // "1000010001110100011010111000111000"
"1000010001110100011010111000111000".length;  // 34
```

但位元運算只會用到 32 位元，所以當 `8888888888 | 1` 運算時，就會去掉多餘的位元，像 `8888888888` 的二進位 (因有 34 位元，會被去掉兩個位元) 最前面的 `10` 這兩個位元就會被去掉，所以實際上位元運算是這樣：

```javascript
parseInt("00010001110100011010111000111000", 2);  // 298954296

298954296 | 1;  // 298954297
```

## 運算結果不精確

雖然 64 位元的精確度算很大了，但 double 也只能表示數字的有限集合，無法表示實數的無限集合，所以浮點運算只能產生近似的結果，捨入到能夠表示的最接近實數

```javascript
0.1 + 0.2;  // 0.30000000000000004

(0.1 + 0.2) + 0.3; // 0.6000000000000001
0.1 + (0.2 + 0.3); // 0.6
```

所以建議用整數運算：

```javascript
(10 + 20) + 30; // 60
10 + (20 + 30); // 60
```

筆記：
- 位元運算會把輸入轉成整數，然後對整數 bit pattern (位元模式) 進行運算，然後將結果轉回標準的 JS 浮點數
  - 看似轉換動作會花費 JS 引擎額外的功夫，最佳化編譯 (optimazing compilers) 有時能推測何時算式運算式或變數被當作整數來用，然後把資料再內部儲存成整數，以避免額外的轉換動作

建議：
- 放大浮點數，以整數來計算就不會發生運算結果不精確的問題
  - 使用整數就能處理 $-2^{53}$ 到 $2^{53}$ 範圍間的所有計算，且不用擔心捨入誤差 (rounding errors)
